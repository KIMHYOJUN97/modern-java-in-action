# CHAPTER 1 자바 8,9,10,11 : 무슨  일이 일어나고 있는가?
자바 8 이전과 이후에는 어떠한 변화가 일어났을까?

다음 코드를 보면서 생각해보자
```Java
//Java8 이전의 구현
Collections.sort(inventory, new Comparator<Apple>){
    public int compare(Apple a1, Apple a2){
        return a1.getWeight().compareTo(a2.getWeight());
    }
}

//Java8 이후의 구현
inventory.sort(comparing(Apple::getWeight));
```
이전의 코드는 구현해야 하는 코드(정렬 코드)를 직접 명시적으로 선언해줘야 했다면, Java 8 이후의 코드는 조금 더 자연어스럽게 처리가 가능해졌다.

## 1.1 또다른 변화
멀티코어 CPU 대중화와 같은 하드웨어적 변화도 자바8에 영향을 미쳤다.
- 지금까지의(Java 8 이전) 대부분의 자바 프로그램은 코어 중 하나만을 사용했다
- 스레드를 사용하면 관리가 어려움.
- Java5에서 스레드 풀, 병렬 실행 컬렉션 등 아주 강력한 도구 도입
- Java7에선 fork/join 프레임워크 제공

### Java 8의 대표적인 기능 3가지
- 스트림 API(병렬 연산 지원, synchronized를 사용하지 않아도 됨)
- 메서드에 코드를 전달하는 기법(코드 전달 방법이 간결해 짐)
- 인터페이스의 디폴트 메서드()

자바 8의 기법: 함수형 프로그래밍
## 1.2 왜 아직도 자바는 변화하는가?
모든 언어는 항상 장,단점이 존재한다.\
예를 들어 C,C++과 같은 언어는 안전성은 부족하지만 작은 런타임 풋프린트 덕분에 운영체제와 다양한 임베디드 시스템에서 여전히 인기를 끌고 있다.

자바는 수많은 유용한 라이브러리를 포함한 잘 설계된 객체지향 언어로 시작했다.
- 쓰레드와 락을 이용한 동시성 지원
- JVM 바이트 코드로 컴파일(모든 브라우저에서 가상 머신 코드를 지원 -> 인터넷 애플릿 프로그램의 주요 언어가 됨)
- 캡슐화 덕분에 C에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적다.

허나 자바에게도 문제가 있었으니, 멀티 코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 데이터를 효과적으로 처리할 필요성이 높아졌다.\
즉 병렬 프로세싱을 활용해야 하는데 Java 8 이전의 자바로는 충분하지 못했다. 이러한 문제들을 해결하기 위해 자바는 어떻게 발전해갔는지 알아보자.

### 스트림 처리
첫 번째 프로그래밍 개념은 스트림 처리(stream processing)이다. 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.\
유닉스 명령행의 예제를 살펴보자
```
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```
sort는 여러 행의 스트림을 입력받아 여러 행의 스트림을 출력으로만들어낸다. 또한 각각의 명령들을 병렬 즉 동시에 작업을 처리한다.\
자바 8에서도 이와 같은 형태로 코드를 처리하기 위해 java.util.stream 패키지가 추가되었다.\
스트림 API는 기존에 한 번에 한 항목을 처리하는 것과 다르게 고수준(SQL 처럼)으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다.\
스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다. 스레드라는 복잡한 작업을 사용하지 않고도 병렬성을 얻을 수 있다는 장점이 있다.

### 동작 파라미터화로 메서드에 코드 전달하기
자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다.

무슨 의미냐면 2023KR0001, 2023US,0002 등의 형식을 가진 송장이 ID가 존재한다 가정해보자.\
이는 각각의 분기(4자리 숫자(2023), 2자리 영문(KR), 4자리 숫자(0001))마다 존재하는 의미가 각각 다르다. 또한 이러한 분기별로 정렬하고 싶다면 sort에 따로 코드를 제공해야 한다.

```Java
//Java8 이전의 구현
Collections.sort(inventory, new Comparator<Apple>){
    public int compare(Apple a1, Apple a2){
        return a1.getWeight().compareTo(a2.getWeight());
    }
}

//Java8 이후의 구현
inventory.sort(comparing(Apple::getWeight));
```
맨 처음 보았던 코드이다. 이 코드를 보면 자바 8 이전의 구현에서는 메서드를 파라미터로 넣기 위해서는 이러한 과정을 거쳤어야 했지만, 자바 8 이후에는 이러한 형태로 표현이 가능해 졌다. **이걸 동적 파라미터화라고 한다.**

### 병렬성과 공유 가변 데이터
세 번째 프로그래밍의 개념은 **병렬성을 공짜로 얻을 수 있다**라는 말에서 시작된다.\
프로그래밍을 시작한 뒤로 느낀것은 모든 일에는 트레이드 오프(trade off)가 따른다는 것이다. 병렬성을 얻음으로써 무엇을 포기해야 할까?\
정답은 코드의 동작 방식을 바꿔야 한다는 것이다. 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다. 보통 다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들려면 공유된 가변 데이터에 접근하지 않아야한다.\
(*물론 기존처럼 synchronized를 이용하면 공유된 가변 데이터를 보호할 수 있지만 성능상 악영향을 끼친다.*)

### 자바가 진화해야 하는 이유
제네릭의 등장으로 List가 List\<String>으로 바뀌었을 때 컴파일을 할 때 많은 에러를 검출함으로써 개발자들의 실수를 줄여나갈 수 있었다.

또 다른 변화로는 고전적인 객체지향 프로그래밍에서 함수형 프로그래밍을 도입했다는 것인데, 가장 큰 예시로는 Iterator 대신 for-each 루프를 사용할 수 있게 된 것이다.\
함수형 프로그래밍에서는 우리가 하려는 작업이 최우선시 되며 그 작업을 어떻게 수행하는지는 별개의 문제로 취급한다. 이러한 점은 고전적인 객체지향 프로그래밍과 상극이다. 하지만, 자바 8에서는 함수형 프로그래밍을 도입함으로써 두 프로그래밍의 장점을 모두 취했다는 점이다.

## 1.3 자바 함수
프로그래밍 언어에서 함수라는 용어는 메서드 특히 정적 메서드와 같은 의미로 사용된다. 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다.

그런데 함수는 왜 필요한 것일까?\
프그래밍 언어의 핵심은 값을 바꾸는 것이다. 값을 바꿀 수 있게 해주는 것을 '일급 값'이고 하는데, 메서드와 클래스 모두 이급 시민 들이다. 따라서 메서드와 클래스는 그 자체로 값이 될 수 없다. 하지만 자바 8 이후에서는 이급 시민을 일급 시민으로 바꿔줄 수 있다.

### 메서드와 람다를 일급 시민으로
메서드를 값 취급 할 수 있게 ***메서드 참조*** 기능이 추가되었다.\
첫 번째로 메서드 참조(method reference)라는 새로운 자바 8 기능이 추가되었다.
```Java
File[] hiddenFile = new File(".").listFiles(new FileFilter()){
    public boolean accept(File file){
        return file.isHidden(); //숨겨진 파일 필터링
    }
}
```
두 번째로는 익명 함수(람다)를 포함하여 함수도 값으로 취급할 수 있다.
```Java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

## 1.4 스트림
모든 자바 애플리케이션은 컬렉션을 만들고 활용한다. 하지만 컬렉션으로 모든 문제가 해결되는 것은 아니다. 다음과 같은 코드를 보면 가독성이 매우 떨어지는 것을 볼 수 있다.
```Java
Map<Curreny, List<Transaction>> transactionByCurrencies = new HashMap<>();
for(Transaction transaction: transactions){
    if(transaction.getPrice >1000){
        Currency currency = transaction.getCurrency();
        List<Transaction> transactionsForcurrency = transactionsByCurrency.get(currency);
        if(transactionsForcurrency == null){
            transactionsForcurrency = new ArrayList<>();
            transactionsByCurrency.put(currency,transactionsForcurrency);
        }
        transactionsForcurrency.add(transaction);
    }
}
```
보기만 해도 어지러운 코드들이다. 이걸 스트림 API를 활용하면 다음과 같이 정리가 가능하다
```Java
Map<Currency, List<Transaction>> transactionByCurrencies = transactions.stream()
                .filter((Transaction t) -> t.getPrice() >1000)
                .collect(groupingBy(Transaction::getCurrency));
```
for-each 루프를 이용해서 각 요소를 반복하는 작업하는 외부 반복보다, 스트림 API를 활용한 내부 반복을 사용하면 훨씬 깔끔하게 처리할 수 있다.\
또한 자바 버전에서 스레드 API로 멀티스레딩 코드를 구현하는 것은 쉽지 않다.\
 이러한 점 또한 스트림에서는 **컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제** 그리고 **멀티 코어 활용의 어려움**을 모두 해결한다.\
 반복되는 패턴으로 주어진 조건에 따라 데이터를 필터링 하거나, 데이터를 추출하거나, 데이터를 그룹화하는 등의 기능이 있다. 이러한 동작들을 쉽게 병렬화가 가능하다.

## 1.5 디폴트 메서드와 자바 모듈
자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 default method를 지원한다\
하지만 필자는 이러면 구현체가 이미 존재하는 다중 상속이 가능한 것일까?라는 궁금증이 생긴다. 이러한 문제는 이미 다이아몬드 상속 문제라고 불리우는데 이는 이후 챕터에서 다루도록 한다.\

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어
자바 8 에서는 NullPointer 예외를 피할 수 있도록 도와주는 Optional<T> 클래스를 제공한다. 상황을 어떻게 처리할지 명시적으로 구현하는 메서드를 포함하고 있다.
